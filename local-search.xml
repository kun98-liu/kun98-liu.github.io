<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang-协程调度器GMP</title>
    <link href="/2022/08/18/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8GMP/"/>
    <url>/2022/08/18/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8GMP/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang协程调度器"><a href="#Golang协程调度器" class="headerlink" title="Golang协程调度器"></a><center>Golang协程调度器</center></h1><h2 id="一、Go调度器的由来"><a href="#一、Go调度器的由来" class="headerlink" title="一、Go调度器的由来"></a>一、Go调度器的由来</h2><blockquote><p> 引言：</p><p>早期的单进程操作系统中，所有进程是顺序执行的，同一时刻只能有一个进程工作。</p><p>单进程时代的两个问题：1. 单一执行流程， 2. 进程阻塞带来CPU浪费</p><hr><p>之后出现了多线程、多进程操作系统。CPU作为调度器，按时间片轮询所有线程，宏观上就实现了多进程同时执行。</p><p>多线程解决了阻塞问题，但带来了新的问题，线程的上下文切换是有成本的。进程或线程越多，切换成本就越大，CPU的资源浪费就越严重。同时，大量的创建线程或进程会消耗大量内存。</p></blockquote><p>操作系统中，将一个线程内部分为用户态和内核态。那么，为啥那么不把这个线程一分为二，形成用户线程-内核线程的结构。我们开发者使用用户线程做接口调用之类的工作，内核线程来负责系统调用，管理硬件等。这样一个模型中，我们可以把内核空间的线程叫做Thread，而用户空间的线程就叫做协程 co-routine。</p><img src="https://raw.githubusercontent.com/kun98-liu/MyPicGo/main/202205201832728.png" style="zoom:67%;" /><p>然而，如果是一个内核线程绑定一个协程，其实也并没有解决引言中所说的多线程带来的CPU浪费，内存浪费等问题。因此，在用户空间里，我们可以使用一个协程调度器，来管理多个协程，实现一个内核线程绑定多个协程。这个模型有点像Java NIO中的 Selector-Channel，我理解应该是同一种思想——多路复用嘛~</p><img src="https://raw.githubusercontent.com/kun98-liu/MyPicGo/main/202205201836265.png" style="zoom:67%;" /><p>再多考虑一步，如果有一个协程阻塞了，那么后面的协程会变得无法执行。为此，我们可以更大胆的设计多线程对应多协程的一个模型，图我就不放了。那么压力此时就来到了这个协程调度器上了。其实，这样的模型和Netty的workGroup用多线程处理更多的通道事件是一样的 。还是那个思想——多路复用来提高利用率。</p><p>在Golang中，coroutine被改名为了goroutine，同时，一个goroutine的内存被控制在了4KB，因此Golang中可以创建超级大量的goroutine。  </p><h2 id="二、Goroutine调度器的GMP模型"><a href="#二、Goroutine调度器的GMP模型" class="headerlink" title="二、Goroutine调度器的GMP模型"></a>二、Goroutine调度器的GMP模型</h2><h3 id="2-1-GMP模型简介"><a href="#2-1-GMP模型简介" class="headerlink" title="2.1 GMP模型简介"></a>2.1 GMP模型简介</h3><p>GMP实际上就是三个符号，G代表goroutine，P代表processor，M代表thread。</p> <img src="https://raw.githubusercontent.com/kun98-liu/MyPicGo/main/202205201938558.png" style="zoom:67%;" /><p>上图就是GMP模型的示意图了，针对图中各个部分，做以下说明：</p><ul><li>全局队列：存放等待运行的G</li><li>P的本地队列：存放不超过256个的等待运行的G；优先将新创建的G放在P的本地队列，如果都满了就放在全局队列</li><li>P列表：程序启动时创建；最多有GOMAXPROCS个，可以配置；</li><li>M列表：操作系统分配给当前GO程序的内核线程数；可以通过SetMAXThreads函数设置；M有个线程池，可以在一个M阻塞时，创建一个新的M；在M空闲时，可以将该M回收</li></ul><h3 id="2-2-调度器的设计策略"><a href="#2-2-调度器的设计策略" class="headerlink" title="2.2 调度器的设计策略"></a>2.2 调度器的设计策略</h3><ul><li>复用线程<ul><li>目的：避免频繁创建和销毁线程M</li><li>work stealing机制：当本线程无可运行的G时，先不销毁线程，而是从其他线程绑定的P里偷取G</li><li>hand off机制： 当本线程因为G进行系统调用而阻塞时，该线程释放绑定的P，把P交给其他空闲的线程M继续执行</li></ul></li><li>利用并行<ul><li>GOMAXPROCS设置P的数量，充分利用多核CPU，实现并行处理</li></ul></li><li>抢占<ul><li>在coroutine中，一个协程要等待正在执行的另一个协程主动让出CPU才执行</li><li>在go中，一个goroutine最多占用CPU10ms，然后就会被别的goroutine抢占CPU</li></ul></li><li>全局G队列<ul><li>当M执行work stealing时，如果从其他P偷不到G时，可以从全局队列获取G</li></ul></li></ul><h3 id="2-3-go-func-经历了什么过程"><a href="#2-3-go-func-经历了什么过程" class="headerlink" title="2.3 go func() 经历了什么过程"></a>2.3 go func() 经历了什么过程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1650776333419-50d3a922-bd53-4bff-b0b6-280e6abc5d74.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10/resize,w_750,limit_0"></p><p>​1、我们通过 go func()来创建一个goroutine；</p><p>​2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</p><p>​3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p><p>​4、一个M调度G执行的过程是一个循环机制；</p><p>​5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</p><p>​6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-如何通过Bitmap实现亿级数据统计</title>
    <link href="/2022/08/18/DataStructure-Bitmap/"/>
    <url>/2022/08/18/DataStructure-Bitmap/</url>
    
    <content type="html"><![CDATA[<h1 id="如何通过Bitmap实现亿级数据统计"><a href="#如何通过Bitmap实现亿级数据统计" class="headerlink" title="如何通过Bitmap实现亿级数据统计"></a>如何通过Bitmap实现亿级数据统计</h1><blockquote><p>问题：给你10亿条u_id，去重后存储。并且，实现O(1)时间复杂度下的查询，添加，删除操作。</p><p>（做Line网测时，遇到了类似问题。。。当时就留下了不学无术的泪。。。）</p></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>说到去重，第一反应一定是HashSet吧。那么用HashSet考虑一下。</p><p>10亿u_id，用int来表示，需要40亿字节，因为int类型所占的空间是4字节。换算一下，就是4GB内存。。。</p><p>如果只给512MB的内存（网测时的题目要求），那就说明这种做法是完全离谱的了。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>尽管每个uid都用了int类型的数来保存，但也没必要在记录时，也用int类型。</p><p>一个int是4个字节，32位。如果假设就存{1，3，5，7} 4个数字，就需要128位的空间。</p><p>然而，实际上这4个数字中，最大的值用二进制表示就是0111，4位足矣。存储4个数字用16位，就足够存储。</p><p>从128 到 16，这就是这道题的核心解决思路 —— <strong>压缩数据</strong>！</p><p>当然方法并不是去掉数字开头的0，以上的说法只是说明，常规方法造成的空间浪费有多大。</p><p><strong>如果我们直接用Bit来记录一个数据的存在与否，那么10亿条数据，就算最大的数据就是INT_MAX，我们不得不开辟一共2的32次方的Bit，所占用的空间最大就是0.5GB，恰好就能满512MB的内存要求。</strong></p><p><strong>这种用一个Bit来记录数据的方式就叫做 Bitmap</strong></p><h2 id="手撕Bitmap"><a href="#手撕Bitmap" class="headerlink" title="手撕Bitmap"></a>手撕Bitmap</h2><p>要用一个Bit代表一个数据，显然不存在bit数组，以java为例，使用byte[] 数组来实现Bitmap即可。</p><p><strong>设计要点</strong></p><ul><li>byte数组的容量需要有这一堆数据中的最大值确定，或者直接用INT_MAX作为最大值。容量应为<code>maxvalue / 8 + 1</code></li><li>在增删查方法中，定义两个重要索引： index | position<ul><li><code>index</code> : 表示byte数组中的索引</li><li><code>position</code> ：表示该byte元素的第几位。</li></ul></li><li>得到这两个索引后，就可以确定代表该<code>num</code> 的bit位。之后，就是3种位运算。</li><li>添加数据，就是让该bit变为1。用或运算。</li><li>查询数据，就是看该bit是否为1，用与运算。</li><li>删除数据，就是让该bit变为0，用异或运算。</li></ul><p>具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Bitmap类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] bits;<span class="hljs-comment">//实际存储数据的容器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxVal;<span class="hljs-comment">//最大值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<span class="hljs-comment">//容量</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bitmap</span><span class="hljs-params">(<span class="hljs-type">int</span> maxVal)</span>&#123;<br>        <span class="hljs-built_in">this</span>.maxVal = maxVal;<br>        <span class="hljs-built_in">this</span>.capacity = (maxval/<span class="hljs-number">8</span>) + <span class="hljs-number">1</span>;<br>        bits[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[capacity];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> num/<span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> num % <span class="hljs-number">8</span>;<br>        <br>        <span class="hljs-type">byte</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; position;<br>        <br>        bits[index] = bits[index] | temp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span> <span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> num / <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> num % <span class="hljs-number">8</span>;<br>        <br>        <span class="hljs-type">byte</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; position;<br>        <br>        <span class="hljs-keyword">return</span> (bits[index] &amp; temp) == temp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span> <span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> num / <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">postion</span> <span class="hljs-operator">=</span> num % <span class="hljs-number">8</span>;<br>        <br>        <span class="hljs-type">byte</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; position;<br>        <br>        bits[index] = bit[index] ^ temp;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Trie前缀树</title>
    <link href="/2022/08/18/DataStructure-Trie%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <url>/2022/08/18/DataStructure-Trie%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀树-｜-Trie-｜-Prefix-Tree"><a href="#前缀树-｜-Trie-｜-Prefix-Tree" class="headerlink" title="前缀树 ｜ Trie ｜ Prefix Tree"></a>前缀树 ｜ Trie ｜ Prefix Tree</h1><p>前缀树，顾名思义，就是由前缀构成的一棵树。</p><p>有什么用呢？</p><ul><li>搜索框里的自动补全</li><li>拼写检查</li><li>9键键盘的单词预测，比如输入 hello，后面提示world</li></ul><p>这些都是前缀树的应用。</p><p>简单的来说，就是将很多不同的字符串，放到同一棵树里，前缀相同的部分构成一个前缀树的节点。</p><p>比如，apple 和 application，就可以变成 appl -&gt; e 和 appl -&gt; ication。</p><h2 id="LeetCode-相关题目"><a href="#LeetCode-相关题目" class="headerlink" title="LeetCode 相关题目"></a>LeetCode 相关题目</h2><blockquote><p>208 Implement Trie (Prefix Tree)</p><p>211 Design Add and Search Words Data Structure</p></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>首先，设计一棵树，肯定要从节点开始。</p><h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><p>在这里，我们规定所有放入前缀树的字符串都是lowercase的字母。</p><p>那么，在每一个节点上，就可以记录会出现的子节点的字母，为了方便进行遍历，可以使用一个长度为26的TrieNode[]数组来记录。根据当前的<code>char - &#39;a&#39;</code> 这个index就可以获得下一层的节点。</p><p>此外，还需要记录，该节点是否是最后一个字母。当然通过遍历当前节点的TrieNode[] 数组也是可以判断是否为end，但是那样也太麻烦了。</p><p>然后，再提供一些方法供调用。</p><p>TrieNode类如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>&#123;<br>    <br>    <span class="hljs-type">boolean</span> isEnd;<br>    <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> <span class="hljs-number">26</span>;<br>    <br>    TrieNode[] links;<span class="hljs-comment">//相当于二叉树里的 TreeNode left, TreeNode right。</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span>&#123;<br>        links = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[R];<span class="hljs-comment">//创建每个节点，都要分配这个数组</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//判断当前节点有没有被ch这个字符连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>&#123;<br>        <span class="hljs-keyword">return</span> links[ch - <span class="hljs-string">&#x27;a&#x27;</span>] != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//在当前节点，获得字符为ch的下一个节点。</span><br>    <span class="hljs-keyword">public</span> TrieNode <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>&#123;<br>        <span class="hljs-keyword">return</span> links[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">//添加下一个字符为ch的节点，并连接到这个树上</span><br>    <span class="hljs-comment">//也就是在数组里赋值上这个新节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">char</span> ch, TrieNode node)</span>&#123;<br>        links[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = node;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnd</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnd</span><span class="hljs-params">()</span>&#123;<br>        isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-comment">//树的根节点，实际上的作用就相当于dummyNode,不表示值，但含有所有首字母的link</span><br>    <span class="hljs-keyword">private</span> TrieNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root =<span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">//把一段字符串放进前缀树里</span><br>    <span class="hljs-comment">//遍历字符串，一个字符一个节点。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; word.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">curCh</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-keyword">if</span>(!node.containsKey(curCh))&#123;<br>                node.put(curCh, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>());<span class="hljs-comment">//links数组里没有这个字符，就新建一个并加入树</span><br>            &#125;<br>            node = node.get(curCh);<span class="hljs-comment">//向下遍历</span><br>        &#125;<br>        <br>        node.setEnd();<span class="hljs-comment">//遍历完，设置当前节点为end</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <br>        <span class="hljs-keyword">return</span> res != <span class="hljs-literal">null</span> &amp;&amp; res.isEnd();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">curCh</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-keyword">if</span>(node.containsKey(curCh))&#123;<br>                node = node.get(curCh);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(prefix);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty-Netty的底层实现：JavaNIO</title>
    <link href="/2022/08/18/Netty-Java-NIO/"/>
    <url>/2022/08/18/Netty-Java-NIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty框架-前传"><a href="#Netty框架-前传" class="headerlink" title="Netty框架 - 前传"></a>Netty框架 - 前传</h1><p>跟着韩顺平老师学完了Netty，深感这种底层框架使用起来必须得有很好的计算机网络的知识。</p><p>果然，转码的路上是不能避免学习基础课程的。</p><h2 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h2><p><strong>总结一句话， Netty是一个异步的，基于事件驱动的网络应用框架，用来开发高性能、高可靠性的网络IO程序。</strong></p><p>Netty的应用场景也比较广泛，比如说：</p><ul><li>RPC框架中往往会使用Netty来作为基础的通信组件。Dubbo，Hadoop···</li><li>游戏行业会使用Netty来搭建服务器之间的通信。</li></ul><h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>如上文所说，Netty是一种网络IO程序。实际上，Netty的底层就是基于JAVA NIO实现的。</p><p>那么 NIO是什么呢？</p><p>Java中共支持了3种I&#x2F;O模型：BIO，NIO，NIO2.0 ( 也称AIO )</p><ul><li><p>BIO</p><ul><li>即 Blocking IO</li><li>是传统的阻塞型IO。服务器会为每一个连接创建一个线程。当这个连接不做任何事情时，就会造成线程资源的浪费</li></ul></li><li><p>NIO</p><ul><li>即 Non-Blocking IO</li><li>同步非阻塞。服务器上每一个线程会处理多个请求，这种实现依赖于IO多路复用（Selector）。多路复用器使用轮询的方式处理I&#x2F;O请求。</li></ul></li><li><p>AIO </p><ul><li>即Asynchronized IO</li><li>异步非阻塞。AIO引入了异步通道的概念，采用Proactor模式。有效的请求才启动线程。适用于连接数较多且连接时间较长的应用。</li></ul></li></ul><h2 id="简单说说NIO"><a href="#简单说说NIO" class="headerlink" title="简单说说NIO"></a>简单说说NIO</h2><h3 id="为什么要用NIO，BIO哪不行了？"><a href="#为什么要用NIO，BIO哪不行了？" class="headerlink" title="为什么要用NIO，BIO哪不行了？"></a>为什么要用NIO，BIO哪不行了？</h3><p>BIO也就是Blocking-IO，指的是阻塞性IO。在连接数小的时候，BIO结合线程池是可以应付的过来的。但是，当请求数很大的时候，BIO就完全没有办法胜任了。因为在BIO中，每个请求都需要创建一个独立的线程，从而和客户端直接建立Socket连接，然后在这个线程上执行读写操作。当并发数大的时候，大量的线程都被创建用来建立连接，但也不一定马上进行读写操作，而是阻塞在那里，等待客户端发送请求。此时，线程资源就形成了极大的浪费。若线程池中所有线程都被使用，那么新的连接请求也无法完成，导致不可用。</p><h3 id="NIO怎么就行了？"><a href="#NIO怎么就行了？" class="headerlink" title="NIO怎么就行了？"></a>NIO怎么就行了？</h3><p>NIO是面向缓冲区，或面向块编程的。数据会读取到一个稍后处理的缓冲区中，需要的时候可以在缓冲区中前后移动，这样就提供了处理过程中的灵活性。</p><p>NIO是非阻塞的。具体表现就是，客户端与服务端建立的连接，需要从一个通道发送请求或读取数据，但只在通道中有数据或有请求的时候，才安排线程去执行任务。如果没有，线程也不会阻塞在那里，而是可以去做别的事情。那么如此，在NIO中，一个线程处理多个连接的任务就可以实现了，正所谓IO多路复用。当有10000个请求过来，使用NIO可能只需要100个线程就能同时处理，而BIO就一定得分配10000个线程才能同时处理。</p><h3 id="比较NIO-amp-BIO"><a href="#比较NIO-amp-BIO" class="headerlink" title="比较NIO &amp; BIO"></a>比较NIO &amp; BIO</h3><ol><li>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I&#x2F;O 的效率比流 I&#x2F;O 高很多。</li><li>BIO 是阻塞的，NIO 则是非阻塞的。</li><li>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li><li>Buffer和Channel之间的数据流向是双向的</li></ol><h2 id="NIO三大组件-Channel-｜-Selector-｜-Buffer"><a href="#NIO三大组件-Channel-｜-Selector-｜-Buffer" class="headerlink" title="NIO三大组件 - Channel ｜ Selector ｜ Buffer"></a>NIO三大组件 - Channel ｜ Selector ｜ Buffer</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>。</p><blockquote><ol><li>Buffer是一个抽象类，继承该类的有ByteBuffer，LongBuffer等。</li><li>在Buffer类里定义了4个重要的属性，mark，position，limit，capacity<ol><li>mark：标记</li><li>position：下一个要被读或写的元素的索引位置，为下次读写做准备</li><li>limit：表示缓冲区的当前终点，不能超过这个位置进行读写。limit可以修改。</li><li>capacity：可以容纳的最大数据量，缓冲区创建时被设定，不能改变。</li></ol></li></ol></blockquote><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ol><li>NIO的通道类似于流，但有些区别如下：<ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul></li><li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li><li>常用的 <code>Channel</code> 类有：**<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code>**。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li><li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li></ol><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><ol><li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li><li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li><li>只有在连接&#x2F;通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销</li></ol><blockquote><ol><li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li><li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li><li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li><li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li><li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li></ol></blockquote><h2 id="NIO网络编程原理图"><a href="#NIO网络编程原理图" class="headerlink" title="NIO网络编程原理图"></a>NIO网络编程原理图</h2><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0019.png" alt="img" style="zoom:75%;" /><blockquote><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li></ol></blockquote><h2 id="实例-NIO网络编程"><a href="#实例-NIO网络编程" class="headerlink" title="实例 - NIO网络编程"></a>实例 - NIO网络编程</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kun98.nio;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.*;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">//创建一个ServerSocketChannel,用来创建ServerSocket</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><br><br>        <span class="hljs-comment">//创建一个Selector对象</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>        <span class="hljs-comment">//绑定端口，让服务器监听</span><br>        serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">6666</span>));<br><br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">//注册serverSocketChannel到Selector</span><br>        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (selector.select(<span class="hljs-number">1000</span>) == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;服务器等待一秒，无连接&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();<br>            <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>                <span class="hljs-comment">//有客户端来连接</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-comment">//生成SocketChannel</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br><br>                    System.out.println(<span class="hljs-string">&quot;客户端连接成功，socketChannel： &quot;</span> + socketChannel.hashCode());<br>                    socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="hljs-number">1024</span>));<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                    channel.read(byteBuffer);<br>                    System.out.println(<span class="hljs-string">&quot;from client: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array()).trim());<br>                &#125;<br>                <span class="hljs-comment">//最后要移除这个key，因为已经处理完了</span><br>                keyIterator.remove();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kun98.nio;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br><br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">socketAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br><br>        <span class="hljs-keyword">if</span>(!socketChannel.connect(socketAddress))&#123;<br>            <span class="hljs-keyword">while</span>(!socketChannel.finishConnect())&#123;<br>                System.out.println(<span class="hljs-string">&quot;连接需要时间，客户端不阻塞&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,kun98!&quot;</span>;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(str.getBytes(StandardCharsets.UTF_8));<br><br>        socketChannel.write(byteBuffer);<br>        System.in.read();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>Java</tag>
      
      <tag>Framework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-SpringMVC的DispatcherServlet解析</title>
    <link href="/2022/08/18/Spring-DispatcherServlet%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/08/18/Spring-DispatcherServlet%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC-执行流程"><a href="#SpringMVC-执行流程" class="headerlink" title="SpringMVC 执行流程"></a>SpringMVC 执行流程</h1><p>首先，一图以概之。</p><p><img src="https://raw.githubusercontent.com/kun98-liu/MyPicGo/main/202204060119174.png" alt="SpringMVC执行流程"></p><p>根据上图，先给出总结：</p><ol><li>前端控制器DispatcherServlet 接收请求，进行请求转发。</li><li>HandlerMapping来寻找Handler，并且返回执行链（包含拦截器方法）。</li><li>HandlerAdapter来执行这个执行链。执行的过程中，先执行拦截器的preHandle方法，然后执行Controller方法。<strong>此时返回ModelAndView对象。</strong></li><li>如果有 postHandle方法，就执行。</li><li>dispatcherServlet调用processDispatchResult方法。</li><li>此方法中，先resolve ViewName获得view对象，然后又将model中的数据render进view里。</li><li>最后把view返回给客户端。</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="首先进入doservice方法"><a href="#首先进入doservice方法" class="headerlink" title="首先进入doservice方法"></a>首先进入doservice方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">this</span>.logRequest(request);<br>        Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;<br>            attributesSnapshot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>            <span class="hljs-type">Enumeration</span> <span class="hljs-variable">attrNames</span> <span class="hljs-operator">=</span> request.getAttributeNames();<br>            label95:<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                String attrName;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (!attrNames.hasMoreElements()) &#123;<br>                        <span class="hljs-keyword">break</span> label95;<br>                    &#125;<br><br>                    attrName = (String)attrNames.nextElement();<br>                &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.cleanupAfterInclude &amp;&amp; !attrName.startsWith(<span class="hljs-string">&quot;org.springframework.web.servlet&quot;</span>));<br><br>                attributesSnapshot.put(attrName, request.getAttribute(attrName));<br>            &#125;<br>        &#125;<br><br>        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="hljs-built_in">this</span>.getWebApplicationContext());<br>        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-built_in">this</span>.localeResolver);<br>        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-built_in">this</span>.themeResolver);<br>        request.setAttribute(THEME_SOURCE_ATTRIBUTE, <span class="hljs-built_in">this</span>.getThemeSource());<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.flashMapManager != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">FlashMap</span> <span class="hljs-variable">inputFlashMap</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);<br>            <span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-literal">null</span>) &#123;<br>                request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));<br>            &#125;<br><br>            request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlashMap</span>());<br>            request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-built_in">this</span>.flashMapManager);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.doDispatch(request, response);<span class="hljs-comment">// 此处进入！！！</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.restoreAttributesAfterInclude(request, attributesSnapshot);<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="进入doDisPatch，开始执行上图中的流程"><a href="#进入doDisPatch，开始执行上图中的流程" class="headerlink" title="进入doDisPatch，开始执行上图中的流程"></a>进入doDisPatch，开始执行上图中的流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">processedRequest</span> <span class="hljs-operator">=</span> request;<br>        <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">multipartRequestParsed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">dispatchException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    processedRequest = <span class="hljs-built_in">this</span>.checkMultipart(request);<br>                    multipartRequestParsed = processedRequest != request;<br>                    mappedHandler = <span class="hljs-built_in">this</span>.getHandler(processedRequest);<span class="hljs-comment">//步骤2，3。获取执行链</span><br>                    <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-built_in">this</span>.noHandlerFound(processedRequest, response);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><span class="hljs-comment">//4.获取HandlerAdapter</span><br>                    <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;GET&quot;</span>.equals(method);<br>                    <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">&quot;HEAD&quot;</span>.equals(method)) &#123;<br>                        <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());<br>                        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response)).checkNotModified(lastModified) &amp;&amp; isGet)&#123;<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                    &#125;<br><span class="hljs-comment">//5.执行拦截器的preHandle</span><br>                    <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><span class="hljs-comment">//5.执行Controller， 6.返回MV</span><br>                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br>                    <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><br>                    <span class="hljs-built_in">this</span>.applyDefaultViewName(processedRequest, mv);<br>                    <span class="hljs-comment">//注意，此时才发生postHandle</span><br>                    mappedHandler.applyPostHandle(processedRequest, response, mv);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception var20) &#123;<br>                    dispatchException = var20;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable var21) &#123;<br>                    dispatchException = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler dispatch failed&quot;</span>, var21);<br>                &#125;<br><br>                <span class="hljs-comment">//进入步骤8-11</span><br>                <span class="hljs-built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception var22) &#123;<br>                <span class="hljs-built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var23) &#123;<br>                <span class="hljs-built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler processing failed&quot;</span>, var23));<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;<br>                <span class="hljs-built_in">this</span>.cleanupMultipart(processedRequest);<br>            &#125;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="最后processDispatchResult"><a href="#最后processDispatchResult" class="headerlink" title="最后processDispatchResult"></a>最后processDispatchResult</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, <span class="hljs-meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="hljs-meta">@Nullable</span> ModelAndView mv, <span class="hljs-meta">@Nullable</span> Exception exception)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-comment">//···省略一些</span><br>        <span class="hljs-keyword">if</span> (mv != <span class="hljs-literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;<br>            <span class="hljs-built_in">this</span>.render(mv, request, response);<span class="hljs-comment">//核心代码就这一句，进去看看是怎么render的！</span><br>            <span class="hljs-keyword">if</span> (errorView) &#123;<br>                WebUtils.clearErrorRequestAttributes(request);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>                mappedHandler.triggerAfterCompletion(request, response, (Exception)<span class="hljs-literal">null</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.localeResolver != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.localeResolver.resolveLocale(request) : request.getLocale();<br>        response.setLocale(locale);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">viewName</span> <span class="hljs-operator">=</span> mv.getViewName();<br>        View view;<br>        <span class="hljs-keyword">if</span> (viewName != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">//8. resolve ViewName!</span><br>            view = <span class="hljs-built_in">this</span>.resolveViewName(viewName, mv.getModelInternal(), locale, request);<br>            <span class="hljs-keyword">if</span> (view == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;Could not resolve view with name &#x27;&quot;</span> + mv.getViewName() + <span class="hljs-string">&quot;&#x27; in servlet with name &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.getServletName() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            view = mv.getView();<br>            <span class="hljs-keyword">if</span> (view == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;ModelAndView [&quot;</span> + mv + <span class="hljs-string">&quot;] neither contains a view name nor a View object in servlet with name &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.getServletName() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Rendering view [&quot;</span> + view + <span class="hljs-string">&quot;] &quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (mv.getStatus() != <span class="hljs-literal">null</span>) &#123;<br>                response.setStatus(mv.getStatus().value());<br>            &#125;<br><br>          <span class="hljs-comment">//10. 把model数据render进view里</span><br>            view.render(mv.getModelInternal(), request, response);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var8) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Error rendering view [&quot;</span> + view + <span class="hljs-string">&quot;]&quot;</span>, var8);<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> var8;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Framework</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-GC Tri-Color Marking</title>
    <link href="/2022/08/18/Golang-GC/"/>
    <url>/2022/08/18/Golang-GC/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GC-Tri-Color-Marking"><a href="#Golang-GC-Tri-Color-Marking" class="headerlink" title="Golang-GC   Tri-Color Marking"></a><center>Golang-GC   Tri-Color Marking</center></h1><blockquote><p>引言：</p><ul><li><p>Go语言的一大特点就是其提供的垃圾回收机制，对于我这样的没有用过C++的初学者而言，简直是一个福音。</p></li><li><p>那么Go语言中的垃圾回收到底是怎么实现的呢？</p><ul><li>答：标记-清除。</li></ul></li><li><p>相比于JVM中各种眼花缭乱的垃圾回收器和多种垃圾回收机制，Go提供的就是标记-清除型的GC。</p></li><li><p>其中，标记采用的是三色标记法，这种方法也用在了JVM的CMS，G1的等垃圾回收器中。</p></li></ul></blockquote><h2 id="三色标记法-基本逻辑"><a href="#三色标记法-基本逻辑" class="headerlink" title="三色标记法 - 基本逻辑"></a>三色标记法 - 基本逻辑</h2><p>实际上，三色标记法就是用三种颜色来标记对象在可达性分析过程中的状态。按照我的理解，就是对存在于GCRoot中的对象进行BFS遍历。</p><p>我们都知道在使用BFS的时候，需要用一个队列来模拟遍历过程。因此就有了三种颜色所表示的意义：</p><blockquote><ol><li>黑色 - 已经从队列中poll出来了对象</li><li>灰色 - 目前正在队列中的对象</li><li>白色 - 还没有进过队列的对象</li></ol></blockquote><p>整个三色标记的过程如下：</p><blockquote><ol><li>所有对象初始均为白色</li><li>从GCRoot开始，用BFS遍历对象，进入队列即标记为灰色。</li><li>将灰色对象所引用的对象加入队列，弹出所有灰色对象并标记为黑色。进入队列的标为灰色。</li><li>一直遍历直到没有新的对象能够加入队列。</li><li>剩余的所有白色对象就是不可达的对象，GC会移除这些对象。</li></ol></blockquote><h2 id="GolangGC中的一些实现细节-hybrid-write-barrier"><a href="#GolangGC中的一些实现细节-hybrid-write-barrier" class="headerlink" title="GolangGC中的一些实现细节 - hybrid write barrier"></a>GolangGC中的一些实现细节 - hybrid write barrier</h2><p>根据上述的有关三色标记法的基本逻辑，其实不难发现整个过程是必须要STW的。然而JVM中的GC早都实现了并发标记的功能了，Golang岂能不用并发标记？</p><p>然而，使用并发标记，势必会在某些情况下出现问题，比如回收了合法的对象。总结来说，当以下两个条件同时被满足时，就会出现问题。</p><blockquote><ol><li>黑色对象持有白色对象的引用</li><li>另一个灰色对象也拥有这个白色对象的引用，但是这个引用被删除了。</li></ol></blockquote><p>为了避免这两个条件被同时满足，Golang在v1.5版本设置了插入屏障和删除屏障。</p><p><strong>插入屏障</strong>：把一个新的对象挂在某个对象下，直接标记这个新对象为灰色。</p><p><strong>删除屏障</strong>：如果要删除一个对象的引用，如果这个对象是白色的就被标记为灰色。</p><blockquote><p>插入写屏障和删除写屏障的短板：</p><ul><li><p>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活； </p></li><li><p>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</p></li></ul></blockquote><p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p><p><strong>混合写屏障</strong>规则</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，<br><span class="hljs-bullet">2.</span> GC期间，任何在栈上创建的新对象，均为黑色。<br><span class="hljs-bullet">3.</span> 被删除的对象标记为灰色。<br><span class="hljs-bullet">4.</span> 被添加的对象标记为灰色。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
