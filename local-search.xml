<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JUC-LongAdder源码解析</title>
    <link href="/2022/09/21/JUC-LongAdder%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/21/JUC-LongAdder%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="J-U-C-LongAdder-amp-LongAccumulator"><a href="#J-U-C-LongAdder-amp-LongAccumulator" class="headerlink" title="J.U.C - LongAdder &amp; LongAccumulator"></a>J.U.C - LongAdder &amp; LongAccumulator</h1><blockquote><p>在高并发、多线程环境下，对一个对象的字段进行修改是很危险的操作。如果不采用特殊的手段，修改后的数据是无法实现与设计一致的。</p></blockquote><ul><li>实现线程安全的修改对象字段大致有以下几种方式：<ul><li>加锁：synchronized加锁，Reentrant Lock加锁</li><li>使用JUC原子类: 如<code>AtomicInteger</code>, <code>LongAdder</code>, <code>LongAccumulator</code></li></ul></li><li>本文将使用4种不同的方式实现多线程环境下的<code>i++</code>操作，并比较不同方式的性能差异及实现原理</li><li>结果显示，JUC下的<code>LongAdder</code>及<code>LongAccumulator</code>性能最为优越</li></ul><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAccumulator;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAdder;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickNum</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickBySync</span><span class="hljs-params">()</span>&#123;<br>        num++;<br>    &#125;<br><br>    <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByAtomicLong</span><span class="hljs-params">()</span>&#123;<br>        atomicLong.getAndIncrement();<br>    &#125;<br><br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAdder</span><span class="hljs-params">()</span>&#123;<br>        longAdder.increment();<br>    &#125;<br><br>    <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>((x,y) -&gt; x + y, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clickByLongAccumulator</span><span class="hljs-params">()</span>&#123;<br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 50 threads, each click 1m times</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1W</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ClickNum</span> <span class="hljs-variable">clickNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClickNum</span>();<br>        <span class="hljs-type">long</span> starttime;<br>        <span class="hljs-type">long</span> endtime;<br><br><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadNum);<br><br>        <span class="hljs-comment">//0</span><br>        starttime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadNum; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span> * _1W; j++) &#123;<br><br>                        clickNum.clickBySync();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch.await();<br>        endtime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;synchronized : &quot;</span> + clickNum.num + <span class="hljs-string">&quot;\t timecost : &quot;</span> + (endtime -starttime));<br><br><br>        <span class="hljs-comment">//1</span><br>        starttime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadNum; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span> * _1W; j++) &#123;<br>                        clickNum.clickByAtomicLong();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch1.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch1.await();<br>        endtime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;clickByAtomicLong : &quot;</span> + clickNum.atomicLong + <span class="hljs-string">&quot;\t timecost : &quot;</span> + (endtime -starttime));<br><br>        <span class="hljs-comment">//2</span><br>        starttime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadNum; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span> * _1W; j++) &#123;<br><br>                        clickNum.clickByLongAdder();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch2.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch2.await();<br>        endtime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;clickByLongAdder : &quot;</span> + clickNum.longAdder.sum() + <span class="hljs-string">&quot;\t timecost : &quot;</span> + (endtime -starttime));<br><br>        <span class="hljs-comment">//3</span><br>        starttime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadNum; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span> * _1W; j++) &#123;<br><br>                        clickNum.clickByLongAccumulator();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    countDownLatch3.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        countDownLatch3.await();<br>        endtime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;clickByLongAccumulator : &quot;</span> + clickNum.longAccumulator.get() + <span class="hljs-string">&quot;\t timecost : &quot;</span> + (endtime -starttime));<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">synchronized :</span> <span class="hljs-number">50000000</span> <span class="hljs-attr">timecost :</span> <span class="hljs-number">1378</span><br><span class="hljs-attr">clickByAtomicLong :</span> <span class="hljs-number">50000000</span>  <span class="hljs-attr">timecost :</span> <span class="hljs-number">2262</span><br><span class="hljs-attr">clickByLongAdder :</span> <span class="hljs-number">50000000</span> <span class="hljs-attr">timecost :</span> <span class="hljs-number">108</span><br><span class="hljs-attr">clickByLongAccumulator :</span> <span class="hljs-number">50000000</span>  <span class="hljs-attr">timecost :</span> <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>使用了4种不同的方式实现50个线程，每个线程让共享变量1million次i++。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs longadder```和```longaccumulator```的耗时仅为100多毫秒，而使用```synchronized```和```AtomicLong```的耗时均在1000ms以上。"><br>## 源码分析<br><br>###  ```Synchronized``` &amp; ```AtomicInteger ``` - 悲观锁&amp;乐观锁<br><br>众所周知，```Synchronized``` 关键字修饰方法时，会对整个对象加锁，具体表现为：在字节码文件中，被```Synchronized``` 关键字修饰的方法前后会插入monitor，即监视器，此为悲观锁的基本实现之一。<br><br>```AtomicInteger```或原子类，采用的CAS思想，实现的是乐观锁，即在线程尝试修改数据时，不会加锁，而是通过Compare and Swap实现修改。<br><br>在读多写少的情况下，读线程可直接获取该字段的值，而写线程因为没有采用加锁操作，且写操作较少，CAS不易失败或自旋次数少，写操作的速度会很快。<br><br>但是，在本文的实验中，对同一个字段的操作全部为写操作（```i++```），因此使用```AtomicInteger```时，CAS的失败次数极高，由此导致的自旋行为使得整体用时甚至超过了```Synchronized``` 悲观锁的实现方式。<br><br><br><br>###  LongAdder &amp; LongAccumulator - 负载均衡 ｜ 动态扩容<br><br>进入```LongAdder```和```LongAccumulator```的源码来看，两者其实非常相似，只是在```LongAccumulator```中多了一个```applyfunc()```。<br><br><br><br>因此，我们就看LongAdder的源码即可。<br><br>```java<br> // increment()方法最终会调用这个方法<br>public void add(long x) &#123;<br>      //声明的一些变量<br>        Cell[] as; long b, v; int m; Cell a;<br>      //判断条件中间是｜｜符号，所以只有当两个条件都是false才不会进入内部<br>      //1.as有没有被初始化，没有的话，第一个条件为false<br>      //2.cas操作更新base值，如果成功了返回false<br>        if ((as = cells) != null || !casBase(b = base, b + x)) &#123;<br>            boolean uncontended = true;<br>          //双重判断as是否被初始化，as Cell数组的某个Cell是否初始化，cas操作某个Cell a的value<br>          //没被初始化 || cas失败 的情况下，才会进一步调用longAccumulate方法<br>            if (as == null || (m = as.length - 1) &lt; 0 ||<br>                (a = as[getProbe() &amp; m]) == null ||<br>                !(uncontended = a.cas(v = a.value, v + x)))<br>                longAccumulate(x, null, uncontended);<br>        &#125;<br>    &#125;<br><br>//非原子操作，得到的值只能保证最终一致性，而不能保证实时一致性<br>    public long sum() &#123;<br>        Cell[] as = cells; Cell a;<br>        long sum = base;<br>        if (as != null) &#123;<br>            for (int i = 0; i &lt; as.length; ++i) &#123;<br>                if ((a = as[i]) != null)<br>                    sum += a.value;<br>            &#125;<br>        &#125;<br>        return sum;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>首先，从<code>sum()</code>方法可以看出，LongAdder的值其实是有两部分组成，一部分是<code>base</code>值，另一部份是<code>Cell[]</code>数组中每个元素的<code>value</code>值求和而得。</li><li><code>longAdder.increment()</code>方法会调用到<code>add()</code>方法。<ul><li><ol><li>在<code>Cell[]</code>数组没初始化的情况下，会尝试cas改变<code>base</code>值<ol><li>如果Cas成功，则结束</li><li>如果失败，则会进入第一个if内部</li></ol></li><li>在<code>Cell[]</code>数组已经初始化的情况下，会直接进去结构体内部</li></ol></li><li>进入第一个if结构的内部<ul><li>判断<code>Cell[]</code>数组是否初始化，取hash值得到的数组元素是否初始化，尝试CAS改变该数组元素的<code>value</code><ul><li>如果CAS成功了，就结束</li><li>未初始化或者 CAS失败了，就调用<code>longAccumulate()</code>方法</li></ul></li></ul></li></ul></li><li>下一步可以看看<code>longAccumulate()</code>方法做了什么</li></ul><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs longAccumtulate()```的代码里有很多的if-else，我们分层来看"><br>```java<br>final void longAccumulate(long x, LongBinaryOperator fn,<br>                              boolean wasUncontended) &#123;<br>        int h;<br>        if ((h = getProbe()) == 0) &#123;<br>            ThreadLocalRandom.current(); // force initialization<br>            h = getProbe();<br>            wasUncontended = true;<br>        &#125;<br>        boolean collide = false;                // True if last slot nonempty<br>        for (;;) &#123;<br>            Cell[] as; Cell a; int n; long v;<br>          //1. Cell[] 已初始化<br>            if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123;<br>              //1.1 Cell数组的最后一个元素未初始化<br>                if ((a = as[(n - 1) &amp; h]) == null) &#123;<br>                    if (cellsBusy == 0) &#123;       // Try to attach new Cell<br>                        Cell r = new Cell(x);   // Optimistically create<br>                        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;<br>                            boolean created = false;<br>                            try &#123;               // Recheck under lock<br>                                Cell[] rs; int m, j;<br>                                if ((rs = cells) != null &amp;&amp;<br>                                    (m = rs.length) &gt; 0 &amp;&amp;<br>                                    rs[j = (m - 1) &amp; h] == null) &#123;<br>                                    rs[j] = r;<br>                                    created = true;<br>                                &#125;<br>                            &#125; finally &#123;<br>                                cellsBusy = 0;<br>                            &#125;<br>                            if (created)<br>                                break;<br>                            continue;           // Slot is now non-empty<br>                        &#125;<br>                    &#125;<br>                    collide = false;<br>                &#125;<br>              //1.2 wasUncontended值是传入进来的，如果是false，则证明在进入该方法前，CAS已经失败。-&gt; 判断是否尝试过CAS<br>                else if (!wasUncontended)       // CAS already known to fail<br>                    wasUncontended = true;      // Continue after rehash<br>              //1.3 wasUncontended已经被修改为true，尝试一次CAS<br>                else if (a.cas(v = a.value, ((fn == null) ? v + x :<br>                                             fn.applyAsLong(v, x))))<br>                    break;<br>              //1.4 CAS失败了，判断Cell数组是否已到达max size或者已经过时<br>                else if (n &gt;= NCPU || cells != as)<br>                    collide = false;            // At max size or stale<br>              //1.5 检查collide标记，如果为false，则更改为true（能走到这一个条件分枝肯定是有冲突），如果已经是true了，则在一下个分支里进行扩容<br>              else if (!collide)<br>                    collide = true;<br>              //1.6 获取自旋锁 -&gt; 扩容<br>                else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;<br>                    try &#123;<br>                        if (cells == as) &#123;      // Expand table unless stale<br>                            Cell[] rs = new Cell[n &lt;&lt; 1];<br>                            for (int i = 0; i &lt; n; ++i)<br>                                rs[i] = as[i];<br>                            cells = rs;<br>                        &#125;<br>                    &#125; finally &#123;<br>                        cellsBusy = 0;<br>                    &#125;<br>                    collide = false;<br>                    continue;                   // Retry with expanded table<br>                &#125;<br>              //获取新的hash值，使得每一次循环都能在不同index处进行CAS<br>                h = advanceProbe(h);<br>            &#125;<br>          //2. 尝试获取自旋锁 - cellsBusy (其实就是个变量) -&gt; 初始化整个Cell数组<br>            else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>                boolean init = false;<br>                try &#123;                           // Initialize table<br>                    if (cells == as) &#123;<br>                        Cell[] rs = new Cell[2];<br>                        rs[h &amp; 1] = new Cell(x);<br>                        cells = rs;<br>                        init = true;<br>                    &#125;<br>                &#125; finally &#123;<br>                    cellsBusy = 0;<br>                &#125;<br>                if (init)<br>                    break;<br>            &#125;<br>          //3. CAS操作base值<br>            else if (casBase(v = base, ((fn == null) ? v + x :<br>                                        fn.applyAsLong(v, x))))<br>                break;                          // Fall back on using base<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>能够进入<code>longAccumulate()</code>这个方法的前提在于，CAS失败和Cell[]数组初始化失败。因此，该方法的主要作用就是：初始化，扩容，再次重试CAS。</p><p>循环体内部可以先分成三个不同条件分枝：</p><ol><li>Cell数组已经初始化</li><li>Cell数组还未初始化，因此尝试去获取自旋锁<code>cellsBusy</code></li><li>获取自旋锁失败，再次尝试CAS修改base值</li></ol><p>后两个分支很明确了，第一个分支内还有多个if-else嵌套：</p><ol><li>如果是最后一个Cell没有初始化，就去尝试attach new Cell</li><li><code>wasUncontended</code>值是传入进来的，如果是false，则证明在进入该方法前，CAS已经失败，在这一轮循环中，<code>wasUncontended</code>会被标记为true，然后在下一次循环中就会再一次尝试CAS</li><li>不论之前的CAS是尝试过而失败了还是根本没有过CAS，都进行一次CAS，如果这次成功就退出循环，如果失败，就进行下一个条件判断</li><li>之后的三个条件都是为了扩容Cell数组。首先先判断是否已经达到max size，如果达到了，就跳过后面的扩容，然后重新获取新的index，进行下一轮循环尝试CAS。如果没达到就进入下一个条件判断</li><li>如果此时<code>collide</code>值仍为false，则改为true，然后进行下一轮循环。如果此时已经被改为true，就证明上一轮循环就已经判定为碰撞了，这一轮循环应该进行扩容操作，所以进入下一个条件判断。</li><li>获取自旋锁，然后进行扩容</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相较于<code>synchronize</code>或原子类这样要么悲观锁要么乐观锁的简单粗暴的实现线程安全地修改共享变量，<code>LongAdder</code>的设计无异于是更加出色的。</p><p><code>LongAdder</code>所采用的策略层层递进：</p><ol><li>首先CAS修改base</li><li>一旦发生CAS失败，就使用Cell数组</li><li>Cell数组要是没初始化就初始化，初始化的时候要是遇到自旋锁占用就再试一次CAS base</li><li>要是用了Cell还冲突说明容量不够，因此先检查是不是Cell没初始化</li><li>如果当前Cell数组都拉满了，就换个位置再试CAS</li><li>如果又失败了，就说明得扩容Cell数组了。</li><li>扩容的时候要检查是不是到max size了，如果已经max size了就没法扩容了，只能换个位置再来CAS。如果不是，那就扩容。</li></ol><p>总的来说，这样的设计可以保证在低并发下，使用简单的CAS实现线程安全，节约资源；在高并发下，使用负载均衡，动态扩容的方式，保证性能，又能兼顾资源占用。</p><p>这样的设计在各类分布式系统中都可以见到，实在是妙！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>J.U.C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.824-lab1</title>
    <link href="/2022/09/13/6-824-lab1/"/>
    <url>/2022/09/13/6-824-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="6-824-lab1"><a href="#6-824-lab1" class="headerlink" title="6.824 - lab1"></a>6.824 - lab1</h1><h3 id="lab1-内容"><a href="#lab1-内容" class="headerlink" title="lab1 内容"></a>lab1 内容</h3><p>实现一个MapReduce程序。</p><ul><li>程序入口在main文件夹下, main&#x2F;mrcoordinator.go, main&#x2F;mrworker.go</li><li>需要编写的代码在mr文件夹下，mr&#x2F;coordinator.go, mr&#x2F;worker.go, mr&#x2F;rpc.go</li></ul><h3 id="lab1-分析"><a href="#lab1-分析" class="headerlink" title="lab1 分析"></a>lab1 分析</h3><p>开始动手写代码之前，必须先把整体框架了解清楚。可以参照mapreduce论文中的架构图。</p><ul><li>首先，从main包入手。<ul><li>mrcoordinator.go为协调器的main入口，其中会调用mr.MakeCoordinator方法生成我们自定义的协调器，并且会循环调用Done()方法来持续检查是否完成所有Task</li><li>mrworker.go为worker的的main入口，其中会加载mrapps文件夹下的mr插件（plugins），之后调用我们自定义的Worker的worker方法。且根据lab要求，worker要单起一个进程，那么Worker方法中则应该采用同步的方式执行task，而不是异步或多线程的执行任务</li></ul></li><li>进入mr文件夹下<ul><li>coordinator.go<ul><li>MakeCoordinator方法会创建Coordinator然后调用serve方法，创建goroutine处理RPC</li><li>我们需要实现协调器的功能主要就是亮点：1、向worker分发任务，2、管理任务状态，3、管理超时任务</li></ul></li><li>worker.go<ul><li>在Worker方法中，我们需要让该worker以循环的方式向协调器索取Task来执行，根据Task类型的不同执行不同的方法。</li><li>尽管worker应该以阻塞的方式执行task，但没必要再执行完task后通知协调器任务完成的这一个动作也阻塞。所以，通知协调器task完成可以用go func异步的来通知，让主线程继续要task来做。</li></ul></li><li>rpc.go<ul><li>学习lab中给的Example代码，自定义Args和Reply用于RPC调用中的数据保存。第一次看到这种用法，是真的帅。</li></ul></li></ul></li></ul><h3 id="lab1-总结"><a href="#lab1-总结" class="headerlink" title="lab1 总结"></a>lab1 总结</h3><ul><li>一开始看这个lab一头雾水，不知何处下手。其实关键在于对照着论文里的那个图，并结合lab的说明，分析清楚这个lab的结构。</li><li>虽然是协调器来分发任务，但实际上这个的主动权应该在worker手里。协调器管的功能应该是管好任务的状态，判断超时，判断任务是否全部做完。</li><li>除了获取任务，做任务之外，其他功能都可以做成异步的。比如，协调器派送任务后启动新线程判断超时，worker完成任务后启动新线程通知协调器任务完成。</li></ul><p>做完这个lab后，感觉没有多复杂，然而其实一共写了有5个小时，总共断断续续用了两天。<br>当中大部分的时间都是处在一个完全没有头绪的状态，只得反复的看lab的说明，看代码中的example，借鉴别人的实现。<br>论文写的很清楚，课程讲的也不难，然而想法落地成代码还是一个很困难的事。<br>还是得多学，多写，多总结。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Distributed System</tag>
      
      <tag>MIT6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-协程调度器GMP</title>
    <link href="/2022/08/18/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8GMP/"/>
    <url>/2022/08/18/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8GMP/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang协程调度器"><a href="#Golang协程调度器" class="headerlink" title="Golang协程调度器"></a><center>Golang协程调度器</center></h1><h2 id="一、Go调度器的由来"><a href="#一、Go调度器的由来" class="headerlink" title="一、Go调度器的由来"></a>一、Go调度器的由来</h2><blockquote><p> 引言：</p><p>早期的单进程操作系统中，所有进程是顺序执行的，同一时刻只能有一个进程工作。</p><p>单进程时代的两个问题：1. 单一执行流程， 2. 进程阻塞带来CPU浪费</p><hr><p>之后出现了多线程、多进程操作系统。CPU作为调度器，按时间片轮询所有线程，宏观上就实现了多进程同时执行。</p><p>多线程解决了阻塞问题，但带来了新的问题，线程的上下文切换是有成本的。进程或线程越多，切换成本就越大，CPU的资源浪费就越严重。同时，大量的创建线程或进程会消耗大量内存。</p></blockquote><p>操作系统中，将一个线程内部分为用户态和内核态。那么，为啥那么不把这个线程一分为二，形成用户线程-内核线程的结构。我们开发者使用用户线程做接口调用之类的工作，内核线程来负责系统调用，管理硬件等。这样一个模型中，我们可以把内核空间的线程叫做Thread，而用户空间的线程就叫做协程 co-routine。</p><img src="https://raw.githubusercontent.com/kun98-liu/MyPicGo/main/202205201832728.png" style="zoom:67%;" /><p>然而，如果是一个内核线程绑定一个协程，其实也并没有解决引言中所说的多线程带来的CPU浪费，内存浪费等问题。因此，在用户空间里，我们可以使用一个协程调度器，来管理多个协程，实现一个内核线程绑定多个协程。这个模型有点像Java NIO中的 Selector-Channel，我理解应该是同一种思想——多路复用嘛~</p><img src="https://raw.githubusercontent.com/kun98-liu/MyPicGo/main/202205201836265.png" style="zoom:67%;" /><p>再多考虑一步，如果有一个协程阻塞了，那么后面的协程会变得无法执行。为此，我们可以更大胆的设计多线程对应多协程的一个模型，图我就不放了。那么压力此时就来到了这个协程调度器上了。其实，这样的模型和Netty的workGroup用多线程处理更多的通道事件是一样的 。还是那个思想——多路复用来提高利用率。</p><p>在Golang中，coroutine被改名为了goroutine，同时，一个goroutine的内存被控制在了4KB，因此Golang中可以创建超级大量的goroutine。  </p><h2 id="二、Goroutine调度器的GMP模型"><a href="#二、Goroutine调度器的GMP模型" class="headerlink" title="二、Goroutine调度器的GMP模型"></a>二、Goroutine调度器的GMP模型</h2><h3 id="2-1-GMP模型简介"><a href="#2-1-GMP模型简介" class="headerlink" title="2.1 GMP模型简介"></a>2.1 GMP模型简介</h3><p>GMP实际上就是三个符号，G代表goroutine，P代表processor，M代表thread。</p> <img src="https://raw.githubusercontent.com/kun98-liu/MyPicGo/main/202205201938558.png" style="zoom:67%;" /><p>上图就是GMP模型的示意图了，针对图中各个部分，做以下说明：</p><ul><li>全局队列：存放等待运行的G</li><li>P的本地队列：存放不超过256个的等待运行的G；优先将新创建的G放在P的本地队列，如果都满了就放在全局队列</li><li>P列表：程序启动时创建；最多有GOMAXPROCS个，可以配置；</li><li>M列表：操作系统分配给当前GO程序的内核线程数；可以通过SetMAXThreads函数设置；M有个线程池，可以在一个M阻塞时，创建一个新的M；在M空闲时，可以将该M回收</li></ul><h3 id="2-2-调度器的设计策略"><a href="#2-2-调度器的设计策略" class="headerlink" title="2.2 调度器的设计策略"></a>2.2 调度器的设计策略</h3><ul><li>复用线程<ul><li>目的：避免频繁创建和销毁线程M</li><li>work stealing机制：当本线程无可运行的G时，先不销毁线程，而是从其他线程绑定的P里偷取G</li><li>hand off机制： 当本线程因为G进行系统调用而阻塞时，该线程释放绑定的P，把P交给其他空闲的线程M继续执行</li></ul></li><li>利用并行<ul><li>GOMAXPROCS设置P的数量，充分利用多核CPU，实现并行处理</li></ul></li><li>抢占<ul><li>在coroutine中，一个协程要等待正在执行的另一个协程主动让出CPU才执行</li><li>在go中，一个goroutine最多占用CPU10ms，然后就会被别的goroutine抢占CPU</li></ul></li><li>全局G队列<ul><li>当M执行work stealing时，如果从其他P偷不到G时，可以从全局队列获取G</li></ul></li></ul><h3 id="2-3-go-func-经历了什么过程"><a href="#2-3-go-func-经历了什么过程" class="headerlink" title="2.3 go func() 经历了什么过程"></a>2.3 go func() 经历了什么过程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/26269664/1650776333419-50d3a922-bd53-4bff-b0b6-280e6abc5d74.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_55,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10/resize,w_750,limit_0"></p><p>​1、我们通过 go func()来创建一个goroutine；</p><p>​2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</p><p>​3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p><p>​4、一个M调度G执行的过程是一个循环机制；</p><p>​5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</p><p>​6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-如何通过Bitmap实现亿级数据统计</title>
    <link href="/2022/08/18/DataStructure-Bitmap/"/>
    <url>/2022/08/18/DataStructure-Bitmap/</url>
    
    <content type="html"><![CDATA[<h1 id="如何通过Bitmap实现亿级数据统计"><a href="#如何通过Bitmap实现亿级数据统计" class="headerlink" title="如何通过Bitmap实现亿级数据统计"></a>如何通过Bitmap实现亿级数据统计</h1><blockquote><p>问题：给你10亿条u_id，去重后存储。并且，实现O(1)时间复杂度下的查询，添加，删除操作。</p><p>（做Line网测时，遇到了类似问题。。。当时就留下了不学无术的泪。。。）</p></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>说到去重，第一反应一定是HashSet吧。那么用HashSet考虑一下。</p><p>10亿u_id，用int来表示，需要40亿字节，因为int类型所占的空间是4字节。换算一下，就是4GB内存。。。</p><p>如果只给512MB的内存（网测时的题目要求），那就说明这种做法是完全离谱的了。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>尽管每个uid都用了int类型的数来保存，但也没必要在记录时，也用int类型。</p><p>一个int是4个字节，32位。如果假设就存{1，3，5，7} 4个数字，就需要128位的空间。</p><p>然而，实际上这4个数字中，最大的值用二进制表示就是0111，4位足矣。存储4个数字用16位，就足够存储。</p><p>从128 到 16，这就是这道题的核心解决思路 —— <strong>压缩数据</strong>！</p><p>当然方法并不是去掉数字开头的0，以上的说法只是说明，常规方法造成的空间浪费有多大。</p><p><strong>如果我们直接用Bit来记录一个数据的存在与否，那么10亿条数据，就算最大的数据就是INT_MAX，我们不得不开辟一共2的32次方的Bit，所占用的空间最大就是0.5GB，恰好就能满512MB的内存要求。</strong></p><p><strong>这种用一个Bit来记录数据的方式就叫做 Bitmap</strong></p><h2 id="手撕Bitmap"><a href="#手撕Bitmap" class="headerlink" title="手撕Bitmap"></a>手撕Bitmap</h2><p>要用一个Bit代表一个数据，显然不存在bit数组，以java为例，使用byte[] 数组来实现Bitmap即可。</p><p><strong>设计要点</strong></p><ul><li>byte数组的容量需要有这一堆数据中的最大值确定，或者直接用INT_MAX作为最大值。容量应为<code>maxvalue / 8 + 1</code></li><li>在增删查方法中，定义两个重要索引： index | position<ul><li><code>index</code> : 表示byte数组中的索引</li><li><code>position</code> ：表示该byte元素的第几位。</li></ul></li><li>得到这两个索引后，就可以确定代表该<code>num</code> 的bit位。之后，就是3种位运算。</li><li>添加数据，就是让该bit变为1。用或运算。</li><li>查询数据，就是看该bit是否为1，用与运算。</li><li>删除数据，就是让该bit变为0，用异或运算。</li></ul><p>具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Bitmap类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] bits;<span class="hljs-comment">//实际存储数据的容器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxVal;<span class="hljs-comment">//最大值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<span class="hljs-comment">//容量</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bitmap</span><span class="hljs-params">(<span class="hljs-type">int</span> maxVal)</span>&#123;<br>        <span class="hljs-built_in">this</span>.maxVal = maxVal;<br>        <span class="hljs-built_in">this</span>.capacity = (maxval/<span class="hljs-number">8</span>) + <span class="hljs-number">1</span>;<br>        bits[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[capacity];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> num/<span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> num % <span class="hljs-number">8</span>;<br>        <br>        <span class="hljs-type">byte</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; position;<br>        <br>        bits[index] = bits[index] | temp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span> <span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> num / <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> num % <span class="hljs-number">8</span>;<br>        <br>        <span class="hljs-type">byte</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; position;<br>        <br>        <span class="hljs-keyword">return</span> (bits[index] &amp; temp) == temp;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span> <span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> num / <span class="hljs-number">8</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">postion</span> <span class="hljs-operator">=</span> num % <span class="hljs-number">8</span>;<br>        <br>        <span class="hljs-type">byte</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; position;<br>        <br>        bits[index] = bit[index] ^ temp;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Trie前缀树</title>
    <link href="/2022/08/18/DataStructure-Trie%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <url>/2022/08/18/DataStructure-Trie%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀树-｜-Trie-｜-Prefix-Tree"><a href="#前缀树-｜-Trie-｜-Prefix-Tree" class="headerlink" title="前缀树 ｜ Trie ｜ Prefix Tree"></a>前缀树 ｜ Trie ｜ Prefix Tree</h1><p>前缀树，顾名思义，就是由前缀构成的一棵树。</p><p>有什么用呢？</p><ul><li>搜索框里的自动补全</li><li>拼写检查</li><li>9键键盘的单词预测，比如输入 hello，后面提示world</li></ul><p>这些都是前缀树的应用。</p><p>简单的来说，就是将很多不同的字符串，放到同一棵树里，前缀相同的部分构成一个前缀树的节点。</p><p>比如，apple 和 application，就可以变成 appl -&gt; e 和 appl -&gt; ication。</p><h2 id="LeetCode-相关题目"><a href="#LeetCode-相关题目" class="headerlink" title="LeetCode 相关题目"></a>LeetCode 相关题目</h2><blockquote><p>208 Implement Trie (Prefix Tree)</p><p>211 Design Add and Search Words Data Structure</p></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>首先，设计一棵树，肯定要从节点开始。</p><h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><p>在这里，我们规定所有放入前缀树的字符串都是lowercase的字母。</p><p>那么，在每一个节点上，就可以记录会出现的子节点的字母，为了方便进行遍历，可以使用一个长度为26的TrieNode[]数组来记录。根据当前的<code>char - &#39;a&#39;</code> 这个index就可以获得下一层的节点。</p><p>此外，还需要记录，该节点是否是最后一个字母。当然通过遍历当前节点的TrieNode[] 数组也是可以判断是否为end，但是那样也太麻烦了。</p><p>然后，再提供一些方法供调用。</p><p>TrieNode类如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>&#123;<br>    <br>    <span class="hljs-type">boolean</span> isEnd;<br>    <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> <span class="hljs-number">26</span>;<br>    <br>    TrieNode[] links;<span class="hljs-comment">//相当于二叉树里的 TreeNode left, TreeNode right。</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span>&#123;<br>        links = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[R];<span class="hljs-comment">//创建每个节点，都要分配这个数组</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//判断当前节点有没有被ch这个字符连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>&#123;<br>        <span class="hljs-keyword">return</span> links[ch - <span class="hljs-string">&#x27;a&#x27;</span>] != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//在当前节点，获得字符为ch的下一个节点。</span><br>    <span class="hljs-keyword">public</span> TrieNode <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>&#123;<br>        <span class="hljs-keyword">return</span> links[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">//添加下一个字符为ch的节点，并连接到这个树上</span><br>    <span class="hljs-comment">//也就是在数组里赋值上这个新节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">char</span> ch, TrieNode node)</span>&#123;<br>        links[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = node;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnd</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnd</span><span class="hljs-params">()</span>&#123;<br>        isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-comment">//树的根节点，实际上的作用就相当于dummyNode,不表示值，但含有所有首字母的link</span><br>    <span class="hljs-keyword">private</span> TrieNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root =<span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">//把一段字符串放进前缀树里</span><br>    <span class="hljs-comment">//遍历字符串，一个字符一个节点。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; word.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">curCh</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-keyword">if</span>(!node.containsKey(curCh))&#123;<br>                node.put(curCh, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>());<span class="hljs-comment">//links数组里没有这个字符，就新建一个并加入树</span><br>            &#125;<br>            node = node.get(curCh);<span class="hljs-comment">//向下遍历</span><br>        &#125;<br>        <br>        node.setEnd();<span class="hljs-comment">//遍历完，设置当前节点为end</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <br>        <span class="hljs-keyword">return</span> res != <span class="hljs-literal">null</span> &amp;&amp; res.isEnd();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">curCh</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-keyword">if</span>(node.containsKey(curCh))&#123;<br>                node = node.get(curCh);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(prefix);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty-Netty的底层实现：JavaNIO</title>
    <link href="/2022/08/18/Netty-Java-NIO/"/>
    <url>/2022/08/18/Netty-Java-NIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty框架-前传"><a href="#Netty框架-前传" class="headerlink" title="Netty框架 - 前传"></a>Netty框架 - 前传</h1><p>跟着韩顺平老师学完了Netty，深感这种底层框架使用起来必须得有很好的计算机网络的知识。</p><p>果然，转码的路上是不能避免学习基础课程的。</p><h2 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h2><p><strong>总结一句话， Netty是一个异步的，基于事件驱动的网络应用框架，用来开发高性能、高可靠性的网络IO程序。</strong></p><p>Netty的应用场景也比较广泛，比如说：</p><ul><li>RPC框架中往往会使用Netty来作为基础的通信组件。Dubbo，Hadoop···</li><li>游戏行业会使用Netty来搭建服务器之间的通信。</li></ul><h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>如上文所说，Netty是一种网络IO程序。实际上，Netty的底层就是基于JAVA NIO实现的。</p><p>那么 NIO是什么呢？</p><p>Java中共支持了3种I&#x2F;O模型：BIO，NIO，NIO2.0 ( 也称AIO )</p><ul><li><p>BIO</p><ul><li>即 Blocking IO</li><li>是传统的阻塞型IO。服务器会为每一个连接创建一个线程。当这个连接不做任何事情时，就会造成线程资源的浪费</li></ul></li><li><p>NIO</p><ul><li>即 Non-Blocking IO</li><li>同步非阻塞。服务器上每一个线程会处理多个请求，这种实现依赖于IO多路复用（Selector）。多路复用器使用轮询的方式处理I&#x2F;O请求。</li></ul></li><li><p>AIO </p><ul><li>即Asynchronized IO</li><li>异步非阻塞。AIO引入了异步通道的概念，采用Proactor模式。有效的请求才启动线程。适用于连接数较多且连接时间较长的应用。</li></ul></li></ul><h2 id="简单说说NIO"><a href="#简单说说NIO" class="headerlink" title="简单说说NIO"></a>简单说说NIO</h2><h3 id="为什么要用NIO，BIO哪不行了？"><a href="#为什么要用NIO，BIO哪不行了？" class="headerlink" title="为什么要用NIO，BIO哪不行了？"></a>为什么要用NIO，BIO哪不行了？</h3><p>BIO也就是Blocking-IO，指的是阻塞性IO。在连接数小的时候，BIO结合线程池是可以应付的过来的。但是，当请求数很大的时候，BIO就完全没有办法胜任了。因为在BIO中，每个请求都需要创建一个独立的线程，从而和客户端直接建立Socket连接，然后在这个线程上执行读写操作。当并发数大的时候，大量的线程都被创建用来建立连接，但也不一定马上进行读写操作，而是阻塞在那里，等待客户端发送请求。此时，线程资源就形成了极大的浪费。若线程池中所有线程都被使用，那么新的连接请求也无法完成，导致不可用。</p><h3 id="NIO怎么就行了？"><a href="#NIO怎么就行了？" class="headerlink" title="NIO怎么就行了？"></a>NIO怎么就行了？</h3><p>NIO是面向缓冲区，或面向块编程的。数据会读取到一个稍后处理的缓冲区中，需要的时候可以在缓冲区中前后移动，这样就提供了处理过程中的灵活性。</p><p>NIO是非阻塞的。具体表现就是，客户端与服务端建立的连接，需要从一个通道发送请求或读取数据，但只在通道中有数据或有请求的时候，才安排线程去执行任务。如果没有，线程也不会阻塞在那里，而是可以去做别的事情。那么如此，在NIO中，一个线程处理多个连接的任务就可以实现了，正所谓IO多路复用。当有10000个请求过来，使用NIO可能只需要100个线程就能同时处理，而BIO就一定得分配10000个线程才能同时处理。</p><h3 id="比较NIO-amp-BIO"><a href="#比较NIO-amp-BIO" class="headerlink" title="比较NIO &amp; BIO"></a>比较NIO &amp; BIO</h3><ol><li>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I&#x2F;O 的效率比流 I&#x2F;O 高很多。</li><li>BIO 是阻塞的，NIO 则是非阻塞的。</li><li>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li><li>Buffer和Channel之间的数据流向是双向的</li></ol><h2 id="NIO三大组件-Channel-｜-Selector-｜-Buffer"><a href="#NIO三大组件-Channel-｜-Selector-｜-Buffer" class="headerlink" title="NIO三大组件 - Channel ｜ Selector ｜ Buffer"></a>NIO三大组件 - Channel ｜ Selector ｜ Buffer</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>。</p><blockquote><ol><li>Buffer是一个抽象类，继承该类的有ByteBuffer，LongBuffer等。</li><li>在Buffer类里定义了4个重要的属性，mark，position，limit，capacity<ol><li>mark：标记</li><li>position：下一个要被读或写的元素的索引位置，为下次读写做准备</li><li>limit：表示缓冲区的当前终点，不能超过这个位置进行读写。limit可以修改。</li><li>capacity：可以容纳的最大数据量，缓冲区创建时被设定，不能改变。</li></ol></li></ol></blockquote><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ol><li>NIO的通道类似于流，但有些区别如下：<ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul></li><li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li><li>常用的 <code>Channel</code> 类有：**<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code>**。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li><li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li></ol><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><ol><li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li><li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li><li>只有在连接&#x2F;通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销</li></ol><blockquote><ol><li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li><li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li><li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li><li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li><li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li></ol></blockquote><h2 id="NIO网络编程原理图"><a href="#NIO网络编程原理图" class="headerlink" title="NIO网络编程原理图"></a>NIO网络编程原理图</h2><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0019.png" alt="img" style="zoom:75%;" /><blockquote><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li></ol></blockquote><h2 id="实例-NIO网络编程"><a href="#实例-NIO网络编程" class="headerlink" title="实例 - NIO网络编程"></a>实例 - NIO网络编程</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kun98.nio;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.*;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">//创建一个ServerSocketChannel,用来创建ServerSocket</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><br><br>        <span class="hljs-comment">//创建一个Selector对象</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>        <span class="hljs-comment">//绑定端口，让服务器监听</span><br>        serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">6666</span>));<br><br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">//注册serverSocketChannel到Selector</span><br>        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (selector.select(<span class="hljs-number">1000</span>) == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;服务器等待一秒，无连接&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();<br>            <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>                <span class="hljs-comment">//有客户端来连接</span><br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-comment">//生成SocketChannel</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br><br>                    System.out.println(<span class="hljs-string">&quot;客户端连接成功，socketChannel： &quot;</span> + socketChannel.hashCode());<br>                    socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="hljs-number">1024</span>));<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                    channel.read(byteBuffer);<br>                    System.out.println(<span class="hljs-string">&quot;from client: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array()).trim());<br>                &#125;<br>                <span class="hljs-comment">//最后要移除这个key，因为已经处理完了</span><br>                keyIterator.remove();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kun98.nio;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br><br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">socketAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br><br>        <span class="hljs-keyword">if</span>(!socketChannel.connect(socketAddress))&#123;<br>            <span class="hljs-keyword">while</span>(!socketChannel.finishConnect())&#123;<br>                System.out.println(<span class="hljs-string">&quot;连接需要时间，客户端不阻塞&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,kun98!&quot;</span>;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(str.getBytes(StandardCharsets.UTF_8));<br><br>        socketChannel.write(byteBuffer);<br>        System.in.read();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>Java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-SpringMVC的DispatcherServlet解析</title>
    <link href="/2022/08/18/Spring-DispatcherServlet%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/08/18/Spring-DispatcherServlet%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC-执行流程"><a href="#SpringMVC-执行流程" class="headerlink" title="SpringMVC 执行流程"></a>SpringMVC 执行流程</h1><p>首先，一图以概之。</p><p><img src="https://raw.githubusercontent.com/kun98-liu/MyPicGo/main/202204060119174.png" alt="SpringMVC执行流程"></p><p>根据上图，先给出总结：</p><ol><li>前端控制器DispatcherServlet 接收请求，进行请求转发。</li><li>HandlerMapping来寻找Handler，并且返回执行链（包含拦截器方法）。</li><li>HandlerAdapter来执行这个执行链。执行的过程中，先执行拦截器的preHandle方法，然后执行Controller方法。<strong>此时返回ModelAndView对象。</strong></li><li>如果有 postHandle方法，就执行。</li><li>dispatcherServlet调用processDispatchResult方法。</li><li>此方法中，先resolve ViewName获得view对象，然后又将model中的数据render进view里。</li><li>最后把view返回给客户端。</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="首先进入doservice方法"><a href="#首先进入doservice方法" class="headerlink" title="首先进入doservice方法"></a>首先进入doservice方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">this</span>.logRequest(request);<br>        Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;<br>            attributesSnapshot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>            <span class="hljs-type">Enumeration</span> <span class="hljs-variable">attrNames</span> <span class="hljs-operator">=</span> request.getAttributeNames();<br>            label95:<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                String attrName;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (!attrNames.hasMoreElements()) &#123;<br>                        <span class="hljs-keyword">break</span> label95;<br>                    &#125;<br><br>                    attrName = (String)attrNames.nextElement();<br>                &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.cleanupAfterInclude &amp;&amp; !attrName.startsWith(<span class="hljs-string">&quot;org.springframework.web.servlet&quot;</span>));<br><br>                attributesSnapshot.put(attrName, request.getAttribute(attrName));<br>            &#125;<br>        &#125;<br><br>        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="hljs-built_in">this</span>.getWebApplicationContext());<br>        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-built_in">this</span>.localeResolver);<br>        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-built_in">this</span>.themeResolver);<br>        request.setAttribute(THEME_SOURCE_ATTRIBUTE, <span class="hljs-built_in">this</span>.getThemeSource());<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.flashMapManager != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">FlashMap</span> <span class="hljs-variable">inputFlashMap</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);<br>            <span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-literal">null</span>) &#123;<br>                request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));<br>            &#125;<br><br>            request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlashMap</span>());<br>            request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-built_in">this</span>.flashMapManager);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.doDispatch(request, response);<span class="hljs-comment">// 此处进入！！！</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.restoreAttributesAfterInclude(request, attributesSnapshot);<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="进入doDisPatch，开始执行上图中的流程"><a href="#进入doDisPatch，开始执行上图中的流程" class="headerlink" title="进入doDisPatch，开始执行上图中的流程"></a>进入doDisPatch，开始执行上图中的流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">processedRequest</span> <span class="hljs-operator">=</span> request;<br>        <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">multipartRequestParsed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">dispatchException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    processedRequest = <span class="hljs-built_in">this</span>.checkMultipart(request);<br>                    multipartRequestParsed = processedRequest != request;<br>                    mappedHandler = <span class="hljs-built_in">this</span>.getHandler(processedRequest);<span class="hljs-comment">//步骤2，3。获取执行链</span><br>                    <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-built_in">this</span>.noHandlerFound(processedRequest, response);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><span class="hljs-comment">//4.获取HandlerAdapter</span><br>                    <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;GET&quot;</span>.equals(method);<br>                    <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">&quot;HEAD&quot;</span>.equals(method)) &#123;<br>                        <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());<br>                        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response)).checkNotModified(lastModified) &amp;&amp; isGet)&#123;<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                    &#125;<br><span class="hljs-comment">//5.执行拦截器的preHandle</span><br>                    <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><span class="hljs-comment">//5.执行Controller， 6.返回MV</span><br>                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br>                    <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><br>                    <span class="hljs-built_in">this</span>.applyDefaultViewName(processedRequest, mv);<br>                    <span class="hljs-comment">//注意，此时才发生postHandle</span><br>                    mappedHandler.applyPostHandle(processedRequest, response, mv);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception var20) &#123;<br>                    dispatchException = var20;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable var21) &#123;<br>                    dispatchException = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler dispatch failed&quot;</span>, var21);<br>                &#125;<br><br>                <span class="hljs-comment">//进入步骤8-11</span><br>                <span class="hljs-built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception var22) &#123;<br>                <span class="hljs-built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var23) &#123;<br>                <span class="hljs-built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler processing failed&quot;</span>, var23));<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;<br>                <span class="hljs-built_in">this</span>.cleanupMultipart(processedRequest);<br>            &#125;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="最后processDispatchResult"><a href="#最后processDispatchResult" class="headerlink" title="最后processDispatchResult"></a>最后processDispatchResult</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, <span class="hljs-meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="hljs-meta">@Nullable</span> ModelAndView mv, <span class="hljs-meta">@Nullable</span> Exception exception)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-comment">//···省略一些</span><br>        <span class="hljs-keyword">if</span> (mv != <span class="hljs-literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;<br>            <span class="hljs-built_in">this</span>.render(mv, request, response);<span class="hljs-comment">//核心代码就这一句，进去看看是怎么render的！</span><br>            <span class="hljs-keyword">if</span> (errorView) &#123;<br>                WebUtils.clearErrorRequestAttributes(request);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>                mappedHandler.triggerAfterCompletion(request, response, (Exception)<span class="hljs-literal">null</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.localeResolver != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.localeResolver.resolveLocale(request) : request.getLocale();<br>        response.setLocale(locale);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">viewName</span> <span class="hljs-operator">=</span> mv.getViewName();<br>        View view;<br>        <span class="hljs-keyword">if</span> (viewName != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">//8. resolve ViewName!</span><br>            view = <span class="hljs-built_in">this</span>.resolveViewName(viewName, mv.getModelInternal(), locale, request);<br>            <span class="hljs-keyword">if</span> (view == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;Could not resolve view with name &#x27;&quot;</span> + mv.getViewName() + <span class="hljs-string">&quot;&#x27; in servlet with name &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.getServletName() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            view = mv.getView();<br>            <span class="hljs-keyword">if</span> (view == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;ModelAndView [&quot;</span> + mv + <span class="hljs-string">&quot;] neither contains a view name nor a View object in servlet with name &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.getServletName() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Rendering view [&quot;</span> + view + <span class="hljs-string">&quot;] &quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (mv.getStatus() != <span class="hljs-literal">null</span>) &#123;<br>                response.setStatus(mv.getStatus().value());<br>            &#125;<br><br>          <span class="hljs-comment">//10. 把model数据render进view里</span><br>            view.render(mv.getModelInternal(), request, response);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var8) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Error rendering view [&quot;</span> + view + <span class="hljs-string">&quot;]&quot;</span>, var8);<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> var8;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Framework</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-GC Tri-Color Marking</title>
    <link href="/2022/08/18/Golang-GC/"/>
    <url>/2022/08/18/Golang-GC/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GC-Tri-Color-Marking"><a href="#Golang-GC-Tri-Color-Marking" class="headerlink" title="Golang-GC   Tri-Color Marking"></a><center>Golang-GC   Tri-Color Marking</center></h1><blockquote><p>引言：</p><ul><li><p>Go语言的一大特点就是其提供的垃圾回收机制，对于我这样的没有用过C++的初学者而言，简直是一个福音。</p></li><li><p>那么Go语言中的垃圾回收到底是怎么实现的呢？</p><ul><li>答：标记-清除。</li></ul></li><li><p>相比于JVM中各种眼花缭乱的垃圾回收器和多种垃圾回收机制，Go提供的就是标记-清除型的GC。</p></li><li><p>其中，标记采用的是三色标记法，这种方法也用在了JVM的CMS，G1的等垃圾回收器中。</p></li></ul></blockquote><h2 id="三色标记法-基本逻辑"><a href="#三色标记法-基本逻辑" class="headerlink" title="三色标记法 - 基本逻辑"></a>三色标记法 - 基本逻辑</h2><p>实际上，三色标记法就是用三种颜色来标记对象在可达性分析过程中的状态。按照我的理解，就是对存在于GCRoot中的对象进行BFS遍历。</p><p>我们都知道在使用BFS的时候，需要用一个队列来模拟遍历过程。因此就有了三种颜色所表示的意义：</p><blockquote><ol><li>黑色 - 已经从队列中poll出来了对象</li><li>灰色 - 目前正在队列中的对象</li><li>白色 - 还没有进过队列的对象</li></ol></blockquote><p>整个三色标记的过程如下：</p><blockquote><ol><li>所有对象初始均为白色</li><li>从GCRoot开始，用BFS遍历对象，进入队列即标记为灰色。</li><li>将灰色对象所引用的对象加入队列，弹出所有灰色对象并标记为黑色。进入队列的标为灰色。</li><li>一直遍历直到没有新的对象能够加入队列。</li><li>剩余的所有白色对象就是不可达的对象，GC会移除这些对象。</li></ol></blockquote><h2 id="GolangGC中的一些实现细节-hybrid-write-barrier"><a href="#GolangGC中的一些实现细节-hybrid-write-barrier" class="headerlink" title="GolangGC中的一些实现细节 - hybrid write barrier"></a>GolangGC中的一些实现细节 - hybrid write barrier</h2><p>根据上述的有关三色标记法的基本逻辑，其实不难发现整个过程是必须要STW的。然而JVM中的GC早都实现了并发标记的功能了，Golang岂能不用并发标记？</p><p>然而，使用并发标记，势必会在某些情况下出现问题，比如回收了合法的对象。总结来说，当以下两个条件同时被满足时，就会出现问题。</p><blockquote><ol><li>黑色对象持有白色对象的引用</li><li>另一个灰色对象也拥有这个白色对象的引用，但是这个引用被删除了。</li></ol></blockquote><p>为了避免这两个条件被同时满足，Golang在v1.5版本设置了插入屏障和删除屏障。</p><p><strong>插入屏障</strong>：把一个新的对象挂在某个对象下，直接标记这个新对象为灰色。</p><p><strong>删除屏障</strong>：如果要删除一个对象的引用，如果这个对象是白色的就被标记为灰色。</p><blockquote><p>插入写屏障和删除写屏障的短板：</p><ul><li><p>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活； </p></li><li><p>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</p></li></ul></blockquote><p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p><p><strong>混合写屏障</strong>规则</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，<br><span class="hljs-bullet">2.</span> GC期间，任何在栈上创建的新对象，均为黑色。<br><span class="hljs-bullet">3.</span> 被删除的对象标记为灰色。<br><span class="hljs-bullet">4.</span> 被添加的对象标记为灰色。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
